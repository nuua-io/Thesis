This chapter defines the Nuua programming language. Nuua is a general purpose programming language with an imperative
paradigm and a statically typed system. The Nuua compiler and virtual machine explained in this thesis are written in C++
with a zero-dependency policy. The interpreter is a register-based bytecode virtual machine.

Nuua's system architecture built in this thesis, as described in \autoref{sec:sys_arch}, consists of a compiler that translates a program written
in Nuua into bytecode instructions and of a virtual machine interpreter that executes those bytecode instructions.

\section{Grammar}
\label{sec:nuua_grammar}

Nuua's grammar is inspired by other existing programming languages by taking advantage of some of the best features some of them offer.
Inspiration comes especially from Python \autocite{python_programming_language}, Rust \autocite{rust_programming_language} and
Go \autocite{go_programming_language}.

The precedence relationship between expressions is heavily inspired by C \autocite{c_programming_language}, D \autocite{d_programming_language},
Rust \autocite{rust_programming_language}, and Dart \autocite{dart_programming_language}. The official documentation for those languages
exposes similar tables for operator precedences and Nuua has taken akin levels of precedence as those.

Nuua does not make use of the \texttt{";"} to separate statements, instead, it uses the same separator as Go. Statements can be separated by
a \texttt{"\textbackslash n"} but it does not make use of the \texttt{"\textbackslash t"} to indicate statements inside blocks, and uses the typical
block separator \texttt{"\{" ... "\}"}.

\subsection{Lexical Grammar}

Lexical grammar is used by the lowest layer of the Nuua system to scan the source language and identify different terminal symbols.
The main difference with the syntax grammar, as exposed in \autocite[Appendix~I]{crafting_interpreters}, is that the syntax grammar is a context-free grammar and lexical grammar is a regular grammar.

Nuua's lexical rules are as follows:

\begin{lstlisting}
DIGIT
    : "0" | ... | "9"
    ;
\end{lstlisting}

Digits are any character from '0' to '9'.

\begin{lstlisting}
ALPHA
    : "a" | ... | "z"
    | "A" | ... | "Z"
    | "_"
    ;
\end{lstlisting}

Alpha are characters that are part of the English alphabet in lower or upper case. It also includes '\_' as a special character.

\begin{lstlisting}
ALPHANUM
    : DIGIT
    | ALPHA
    ;
\end{lstlisting}

Alphanum are characters that are either part of the alphabet or are digits.

\begin{lstlisting}
INTEGER_EXPR
    : DIGIT+
    ;
\end{lstlisting}

Integers are a single digit or more found sequentially without spaces. The integer sign is not represented here.

\begin{lstlisting}
FLOAT_EXPR
    : DIGIT+ "." DIGIT+
    ;
\end{lstlisting}

Floats are like integers but require a dot followed by a digit or more, creating a decimal number.

\begin{lstlisting}
BOOL_EXPR
    : "true"
    | "false"
    ;
\end{lstlisting}

Bools are either 'true' or 'false', that are keywords.

\begin{lstlisting}
STRING_EXPR
    : '"' @'"' '"'
    ;
\end{lstlisting}

Strings represent a character string with the possibility to escape '"' by using a '\textbackslash' as a prefix, more on that in the upcoming sections.

\begin{lstlisting}
IDENTIFIER
    : ALPHA ALPHANUM*
    ;
\end{lstlisting}

Identifiers are an alpha character followed by an optional one or more alphanumeric character.

\subsection{Syntax Grammar}

The syntax grammar is used by the parser to build the abstract syntax tree that determines the program's execution flow.
These rules include all top-level declarations, statements, and expressions.

\subsubsection{Program and Top Level Declarations}
\label{sec:program_tld}

\begin{lstlisting}
program
    : top_level_declaration*
    ;
\end{lstlisting}

A Nuua program is a list of top-level declarations.

\begin{lstlisting}
top_level_declaration
    : use_declaration "\n"
    | fun_declaration "\n"
    | class_declaration "\n"
    | export_declaration "\n"
    ;
\end{lstlisting}

A top-level declaration can only be one of the specified rules. Top-level declarations are
a special type of declaration that can only be declared on the module and not inside other blocks.

\begin{lstlisting}
use_declaration
    : "use" STRING_EXPR
    | "use" IDENTIFIER ("," IDENTIFIER)* "from" STRING_EXPR
    ;
\end{lstlisting}

A use declaration is used to import other top-level declarations from other modules. By using the first rule, Nuua imports all the
exported targets of the module pointed by STRING\_EXPR. Otherwise, Nuua imports the specified targets from the modules.

\begin{lstlisting}
fun_declaration
    : "fun" IDENTIFIER "(" parameters? ")" (":" type)? fun_body;
    ;
parameters
    : variable_declaration ("," variable_declaration)*
    ;
fun_body
    : "->" expression "\n"
    | "=>" statement
    | "{" "\n" statement* "}" "\n"
    ;
\end{lstlisting}

A function is defined using the keyword \texttt{fun} followed by the function name, and a list of optional parameters enclosed in parentheses.
The function type is specified after the parameter list by using \texttt{:}. The return type might not be present if the function has no return value.
The function body is specified in three different ways depending on the type of the function body that is expected.

\begin{lstlisting}
class_declaration
    : "class" "{" class_statement* "}"
    ;
class_statement
    : variable_declaration
    | fun_declaration
    ;
\end{lstlisting}

A class uses a keyword \texttt{class} and expects zero or more class statements.

\begin{lstlisting}
export_declaration
    : "export" top_level_declaration
    ;
\end{lstlisting}

An export declaration marks the following top-level declaration as exported, making it available for other modules to import it using the
use declaration.

\begin{lstlisting}
statement
    : variable_declaration "\n"
    | if_statement "\n"
    | while_statement "\n"
    | for_statement "\n"
    | return_statement "\n"
    | print_statement "\n"
    | expression_statement "\n"
    ;
\end{lstlisting}

Statements are used to change the program's flow or indicate simple actions like declaring a variable.

\begin{lstlisting}
variable_declaration
    : IDENTIFIER ":" type
    | IDENTIFIER ":" type "=" expression
    | IDENTIFIER ":" "=" expression
    ;
\end{lstlisting}

A variable declaration may have a type assigned with it, or the declaration type will be inferred from the initializer.

\begin{lstlisting}
if_statement
    : "if" expression if_body el_if* else?
    ;
if_body
    : "=>" statement "\n"
    | "{" "\n" statement* "}"
    ;
el_if
    : "elif" expression if_body
    ;
else
    : "else" expression if_body
    ;
\end{lstlisting}

An \texttt{if} statement is declared with the \texttt{if} keyword followed by the expression of its condition.
The \texttt{if} body may be declared in two different ways depending on the if body. The \texttt{elif} word may be used as a shorthand
to an \texttt{else} followed by an "if" inside. An optional \texttt{else} condition may be added at the end of the \texttt{if}.

\begin{lstlisting}
while_statement
    : "while" expression while_body
    ;
while_body
    : "=>" statement "\n"
    | "{" "\n" statement* "}"
    ;
\end{lstlisting}

A \texttt{while} statement uses the \texttt{while} keyword followed by the expression of the condition and the \texttt{while} body, that can be specified
in two different ways depending on the body contents.

\begin{lstlisting}
for_statement
    : "for" IDENTIFIER ("," IDENTIFIER)? "in" expression for_body
    ;
for_body
    : "=>" statement
    | "{" "\n" statement* "}"
    ;
\end{lstlisting}

A \texttt{for} statement acts is a way to interate a nuua iterator \autoref{fig:nuua_iterators}.
It gets declared by using the \texttt{for} keyword followed by an identifier that will be used to store the element
in the iterator. An optional second identifier may be given in case the loop index needs to be stored as well.
Those values change in every iteration. After the identifiers, the \texttt{in} keyword is expected, followed by the iterator expression and the
\texttt{for} body, that can be declared in two different ways depending on its content.

\begin{lstlisting}
return_statement
    : "return" expression?
    ;
\end{lstlisting}

A \texttt{return} statement uses the \texttt{return} keyword and an optional expression to return.

\begin{lstlisting}
print_statement
    : "print" expression?
    ;
\end{lstlisting}

The \texttt{print} expression is a statement that outputs an expression to the screen. This is a temporary statement used while
Nuua is not able to properly read and write to files (stdout / stdin) in this specific case.

\begin{lstlisting}
expression_statement
    : expression
    ;
\end{lstlisting}

An expression statement may be used as an expression whose value is not used or no value is returned from it.

\subsubsection{Expressions}
\label{sec:grammar_expressions}

Expressions are grouped in different production rules depending on their precedence, this is done due to the parsing strategy used and
helps to visualize the precedence by reading the grammar.

\begin{lstlisting}
expression
    : assignment
    ;
\end{lstlisting}

An expression is reduced to an assignment.

\begin{lstlisting}
assignment
    : range ("=" range)*
    ;
\end{lstlisting}

An assignment expression is written by an expression on the left-hand side and on the right-hand side with a \texttt{=} in the middle.

\begin{lstlisting}
range
    : logical_or ((".." | "...") logical_or)*
    ;
\end{lstlisting}

A range expression is written by an expression on the left-hand side and on the right-hand side with a \texttt{..} or \texttt{...} in the middle. Depending
if the range is exclusive or inclusive.

\begin{lstlisting}
logical_or
    : logical_and ("or" logical_and)*
    ;
\end{lstlisting}

A logical \texttt{or} is a binary operation with the keyword \texttt{or} in the middle.

\begin{lstlisting}
logical_and
    : equality ("and" equality)*
    ;
\end{lstlisting}

A logical \texttt{and} is a binary operation with the keyword \texttt{and} in the middle.

\begin{lstlisting}
equality
    : comparison (("!=" | "==") comparison)*
    ;
\end{lstlisting}

An equality comparison is a binary operation with a \texttt{!=} or \texttt{==} in the middle depending if the check needs to be negated or not.

\begin{lstlisting}
comparison
    : addition ((">" | ">=" | "<" | "<=") addition)*
    ;
\end{lstlisting}

A comparison is similar to equality but checks the values to determine if the left-hand side is greater, greater than, lower and lower than the
right-hand side.

\begin{lstlisting}
addition
    : multiplication (("-" | "+") multiplication)*
    ;
\end{lstlisting}

An addition is used to perform an addition or subtraction of two values.

\begin{lstlisting}
multiplication
    : cast (("/" | "*") cast)*
    ;
\end{lstlisting}

Multiplication is used to perform multiplication or division of two values.

\begin{lstlisting}
cast
    : unary_prefix ("as" type)*
    ;
\end{lstlisting}

A cast performs a type cast of the values on the left-hand side to the value of the right-hand side by using the \texttt{as} keyword.

\begin{lstlisting}
unary_prefix
    : ("!" | "+" | "-") unary_prefix
    | unary_postfix
    ;
\end{lstlisting}

The unary prefixes are used to change a value state by prefixing the operation.

\begin{lstlisting}
unary_postfix
    : primary unary_p*
    ;
unary_p
    : "[" expression "]"
    | slice
    | "(" arguments? ")"
    | "." IDENTIFIER;
    ;
slice
    : "[" expression? ":" expression? (":" expression?)? "]"
    ;
arguments
    : expression ("," expression)*
    ;
\end{lstlisting}

The unary postfixes are used to either access a value or mutate it's content, to slice it's contents, to call a value or to access a value property.

\begin{lstlisting}
primary
    : BOOL_EXPR
    | INTEGER_EXPR
    | FLOAT_EXPR
    | STRING_EXPR
    | IDENTIFIER
    | LIST_EXPR
    | DICTIONARY_EXPR
    | OBJECT_EXPR
    | "(" expression ")"
    ;
\end{lstlisting}

Primary expressions have the highest precedence and are mostly native types, with the exception of the expression group.

\begin{lstlisting}
OBJECT_EXPR
    : IDENTIFIER "{" object_args? "}"
    ;
object_args
    : IDENTIFIER ":" expression ("," IDENTIFIER ":" expression)*
    ;
\end{lstlisting}

An object is defined by an identifier containing the class name, followed by optional arguments surrounded by \texttt{\{} and \texttt{\}} to
initialize the class properties.

\begin{lstlisting}
LIST_EXPR
    : "[" expression ("," expression)* "]"
    ;
\end{lstlisting}

Lists can't be empty, so at least one expression must be provided.

\begin{lstlisting}
DICTIONARY_EXPR
    : "{" IDENTIFIER ":" expression ("," IDENTIFIER ":" expression)* "}"
    ;
\end{lstlisting}

Dictionaries, like lists, can't be empty, so at least one expression must be provided.

\subsection{Operator Precedence}

Given that expressions are grouped by their precedence, the operator precedence table of Nuua is as follows:

\begin{table}[H]
    \centering
    \begin{tabular}{ l l l }
        \textbf{Level} & \textbf{Operators} & \textbf{Associativity} \\
        \texttt{1} & \texttt{A[B], A[B:C:D], A(B, C, D, ...), A.B} & Left-to-right \\
        \texttt{2} & \texttt{!A, +A, -A} & Right-to-left \\
        \texttt{3} & \texttt{A as B} & Left-to-right \\
        \texttt{4} & \texttt{A/B, A*B} & Left-to-right \\
        \texttt{5} & \texttt{+A, -A} & Left-to-right \\
        \texttt{6} & \texttt{A\textgreater B, A\textgreater =B, A\textless B, A\textless =B} & Left-to-right \\
        \texttt{7} & \texttt{A!=B, A==B} & Left-to-right \\
        \texttt{8} & \texttt{A and B} & Left-to-right \\
        \texttt{9} & \texttt{A or B} & Left-to-right \\
        \texttt{10} & \texttt{A..B, A...B} & Left-to-right \\
        \texttt{11} & \texttt{A=B} & Right-to-left \\
    \end{tabular}
    \caption{Nuua operator precedence from highest to lowest with the associativity}
    \label{fig:nuua_operator_precedence}
\end{table}

\subsection{Keywords and Reserved Words}

Keywords are a special subset of identifiers that have a special meaning in a Nuua program.
A reserved word is an identifier that can't be used as such, and in Nuua, no keywords can be used as identifiers therefore
making all keywords reserved words at the same time.
All keywords can already be identified by looking at the grammar rules, the following list shows
all of the keywords in Nuua.\\

\begin{tasks}[counter-format = (tsk[r]), label-width = 2.5cm](4)
        \task \texttt{true}
        \task \texttt{false}
        \task \texttt{as}
        \task \texttt{or}
        \task \texttt{and}
        \task \texttt{if}
        \task \texttt{else}
        \task \texttt{for}
        \task \texttt{in}
        \task \texttt{while}
        \task \texttt{return}
        \task \texttt{print}
        \task \texttt{class}
        \task \texttt{fun}
        \task \texttt{use}
        \task \texttt{from}
        \task \texttt{elif}
        \task \texttt{export}\\
\end{tasks}

More information about the \texttt{print} keyword and why it does exist can be found in \autoref{sec:print_statement}.

\subsection{Escaped Characters}
\label{sec:espaced_chars}

There are some characters that can be escaped in Nuua, for example when the value \texttt{'"'} wants to be used inside
a string where the delimiters are also \texttt{'"'}. To escape a character, the prefix \texttt{\textbackslash} needs to be used followed
by the character willing to escape. The following list gives a view of all the available characters that allow beeing escaped found in Nuua.\\

\begin{tasks}[counter-format = (tsk[r]), label-width = 2cm](2)
        \task \texttt{\textbackslash}
        \task \texttt{'}
        \task \texttt{"}
        \task \texttt{n}
        \task \texttt{t}
        \task \texttt{r}
        \task \texttt{b}
        \task \texttt{f}
        \task \texttt{v}
        \task \texttt{0}\\
\end{tasks}

\section{Scopes}
\label{sec:nuua_scopes}

Scopes refer to the visible area of the variables, in other words, it determines where the association between a variable name
and its value (known as name binding) is valid. This area is known as a scope block.

Nuua have two levels of scope blocks:

\begin{enumerate}
    \item \emph{Module scope}: Any top-level declaration found in Nuua is bound to the module scope. Any other module won't see that
        top-level declaration unless it is exported and the module is trying to use it.
    \item \emph{Block scope}: Any declaration found in any statement that contains blocks (statements found in \autoref{fig:nuua_blocks})
        is only valid inside of the block.
\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{ l l }
        \textbf{Statement} & \textbf{Blocks} \\
        Function declaration & Body \\
        Class declaration & Body \\
        If statement & Then and Else \\
        While statement & Body \\
        For statement & Body \\
    \end{tabular}
    \caption{Nuua statements with scope blocks}
    \label{fig:nuua_blocks}
\end{table}

\section{Entry point}

A Nuua program requires an entry point to start executing the instructions. The entry point in a Nuua program is a
function that must be called \texttt{main}. This function must exist in the initial module. If the function does not
exist an error is thrown prior to execution. The \texttt{main} function needs at least one argument of type \texttt{[string]}
that does contain the command line arguments.

The Nuua virtual machine does automatically call the \texttt{main} function upon starting executing the bytecode with the command
line arguments of the call.

An example \texttt{main} may be as follows:

\begin{lstlisting}
fun main(argv: [string]) {
    // ...
}
\end{lstlisting}

\section{Data types}

This section defines all the Nuua data types that are supported. Each value in Nuua
has a type associated with it, meaning that each value must belong to a certain data type.
A value can't belong to multiple data types at once but can be cast to others if a change is required.

\subsection{Integers}

Integers are named as \texttt{int} and they are a subset of $\mathbb{Z}$. It includes 0
and the integers are stored using $64$ bits using two's complement. Meaning its range for a given integer $x$ is:

\begin{center}
$-2^{64 - 1} < x < 2^{64 - 1} - 1$
\end{center}

\subsection{Floats}

Floats are named as \texttt{float} and they are C++ \texttt{double} precision points that use a total of $64$ bits. $52$ fraction bits, $11$ bits
of exponent and $1$ sign bit.

\subsection{Booleans}

Booleans are named as \texttt{bool} and they are simple booleans, they can be either \texttt{true} or \texttt{false} and they are stored in
a C++ \texttt{bool} type, usually using 8 bits to store it.

\subsubsection{Examples}

\begin{lstlisting}
true
false
\end{lstlisting}

\subsection{Strings}

Strings are named as \texttt{string} and they are used to manipulate arrays of chars. It's implementation uses
a C++ \texttt{std::string} and it's planned to support wider characters as mentioned in \autoref{sec:forthcomming}. It can store any text that's surrounded by \texttt{'"'}.

\subsection{Lists}

Lists are named as \texttt{[type]} and they are used to manipulate a list of other values. They can only have a single
type as the inner list items, so all the list items need to be of the same type.

\subsection{Dictionaries}

Dictionaries are named as \texttt{\{type\}} and they are used to store values of the same type. However, unlike lists, they
use a string-based mapping, allowing each value to be bound to a specific string key, instead of an integer index as the key.
Dictionaries, like lists, can only store 1 type of values. So each key can only store the same type.

\subsection{Functions}

The only way to define a function is by using the "fun" keyword as noted in \autoref{sec:program_tld}. However, functions in Nuua
act as first-class values, meaning that values can contain a function, allowing the function to change without actually changing its type.
The function type needs to be consistent. So even if the function changes, it will always accept the same arguments and it will return the same data type.
Function types are named as \texttt{(T1, T2, ..., TN -> TR)}. where \texttt{T1} to \texttt{TN} are the types of the function parameters.
If the function has a return type, say \texttt{TR}, it needs to be specified with a simple arrow pointing at it the end of the function type.

To see how functions are declared head to \autoref{sec:statements_function}

\subsubsection{Examples}

Function without parameters nor return type.
\begin{lstlisting}
()
\end{lstlisting}
Function with 2 parameters of type int and a float return type.
\begin{lstlisting}
(int, int -> float)
\end{lstlisting}
Function without parameters and a return type of a list of strings.
\begin{lstlisting}
(-> [string])
\end{lstlisting}
Function with two parameters of type int and bool and no return type.
\begin{lstlisting}
(int, bool)
\end{lstlisting}

\subsection{Objects}

Objects are named according to the class they represent. If a class is named \texttt{Person} the type name is \texttt{Person}.

\section{Statements}

This section explains and gives examples to all statements found in Nuua.

Some of the statements may have already been mentioned briefly in \autoref{sec:program_tld}.

\subsection{Use Declaration}

The use declaration is used when a module needs to use a top-level declaration
that is found in another module. The target module is the string given in the use declaration. A path system is used to search for the file,
first trying to find it relatively from the current module path, ending at the standard library folder that comes with Nuua.

The use declaration comes in two different shapes. By using the use declaration with a single string it imports all the top level
declarations that are exported in the target module. Instead, by determining the "use" identifiers, you may import only selected top-level
declarations.

\subsubsection{Caveats}

\begin{itemize}
    \item The target module path given in the use declaration can use a relative or absolute path.
    \item If the target module path does not have the \texttt{".nu"} extension, it will be added automatically.
    \item If the target module is not found in any path, an error is thrown before any execution starts.
    \item If a target top-level declaration is not found in the target module an error is thrown before any execution starts.
    \item If the top level declaration is not exported another error will be thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

Import all exported targets in a relative file path named "test.nu"
\begin{lstlisting}
use "test"
\end{lstlisting}
Import \texttt{a} and \texttt{b} from a relative file path named "test.nu"
\begin{lstlisting}
use a, b from "./test.nu"
\end{lstlisting}
Import \texttt{a} from an absolute file path in "C:/Nuua/test.nu"
\begin{lstlisting}
use a from "C:/Nuua/test.nu"
\end{lstlisting}

\subsection{Function Declaration}
\label{sec:statements_function}

A function declaration creates a function value and a data type given the function parameters and return value.
Once the function value is created, it's then added in a new variable with the function name. That variable can be
modified since functions are first-class values in Nuua. The variations in a function body exist to minimize the
code length in certain situations (When a function is a single return expression, a single statement or a block of statements).

\subsubsection{Caveats}

\begin{itemize}
    \item No function overloading is allowed.
    \item Function parameters do not allow default values.
    \item If the function returns a value, you are expected to, at least, write a single return statement in the top level of the
        function block.
    \item Functions without return type can't be used as formal expressions since they contain no values.
\end{itemize}

\subsubsection{Examples}

Function without parameters and no return type.
\begin{lstlisting}
fun a() {
    print "Hello, World"
}
\end{lstlisting}
Function without parameters and return type.
\begin{lstlisting}
fun b(): string {
    return "Hello, World"
}
\end{lstlisting}
Function with parameters and no return type.
\begin{lstlisting}
fun c(x: string) {
    print "Hello, " + x
}
\end{lstlisting}
Function with parameters and return type.
\begin{lstlisting}
fun d(x: string): string {
    return "Hello, " + x
}
\end{lstlisting}
Single statement function.
\begin{lstlisting}
fun e(x: string): string => return "Hello, " + x
\end{lstlisting}
Single expression function.
\begin{lstlisting}
fun f(x: string): string -> "Hello, " + x
\end{lstlisting}

\subsection{Class Declaration}

A class declaration creates a data type of the given class structure. This type can then be used as a regular type
to specify values of the given class. To create an object of a given class you can use the object expression as explained in \autoref{sec:object_expression}.
Classes act as structs with the fact that they can also contain methods bound to them. Class methods have a variable called \texttt{"self"}
as a self-reference to the object to mutate its state.

\subsubsection{Caveats}

\begin{itemize}
    \item Class properties can't have default values. Values are defined when creating the object using an object expression.
    \item Self-references to the same type are allowed.
    \item There is no class inheritance.
\end{itemize}

\subsubsection{Examples}

Simple class to represent a person.
\begin{lstlisting}
class Person {
    name: string
    age: int
    fun show() {
        print self.name + ", " + self.age as int
    }
}
\end{lstlisting}

\subsection{Export Declaration}

The export declaration is used when a module wants to make a top-level declaration available to use for other
modules. Marking a top-level declaration as exported allows other modules to import and use it.

\subsubsection{Caveats}

\begin{itemize}
    \item You can't export another export.
\end{itemize}

\subsubsection{Examples}

Export a function
\begin{lstlisting}
export fun add(a: int, b: int): int {
    return a + b
}
\end{lstlisting}
Export a class.
\begin{lstlisting}
export class Person {
    name: string
    age: int
}
\end{lstlisting}

\subsection{Variable Declaration}

Variable declarations are scoped to the block where they are declared as mentioned in \autoref{sec:nuua_scopes}.
They can be used from the block they have been declared and on the lexical blocks that may exist inside of it.
A variable with the same name can't be declared in the same lexical block but multiple lexical
blocks may have the same variable name. When getting the value of a variable, the lookup starts from the current block and goes back to previous blocks.

\subsubsection{Caveats}

\begin{itemize}
    \item Even if multiple blocks have the same variable name, they all point to different values.
    \item If a variable is declared with an initializer, the type can be inferred by leaving the type empty.
    \item If a variable is declared without an initializer, the value is default initialized to a zero-state.
    \item If a variable is declared in a block that already contains a variable with the same name, an error is thrown before execution.
\end{itemize}

\subsubsection{Examples}

Simple variable declaration (defaults to \texttt{int}'s zero state, in this case 0).
\begin{lstlisting}
a: int
\end{lstlisting}
Variable declaration with an initializer.
\begin{lstlisting}
b: int = 10
\end{lstlisting}
Variable declaration with an inferred \texttt{int} type.
\begin{lstlisting}
c := 10
\end{lstlisting}

\subsection{If Statement}

An \texttt{if} statement is used to execute a block of code when a certain expression (known as condition) evaluates
to \texttt{true} known as the \texttt{then} block.
The \texttt{if} statement can also execute another block if the condition is \texttt{false} known as the \texttt{else} block.
The \texttt{else} block can be defined using the \texttt{"else"} keyword.
An if statement has a shorthand for defining another if inside the \texttt{else} block, making nested if statements easier to write.
This syntax uses the \texttt{"elif"} keyword and acts the same way as defining an \texttt{else} block with another if statement inside.
Additionally, the if statement body may be defined in different ways depending on the body type. If the body consists of a single statement,
shorthands can be used to minimize the lines of code.

\subsubsection{Caveats}

\begin{itemize}
    \item The condition must always be a boolean. Explicit casting is needed.
\end{itemize}

\subsubsection{Examples}

Simple if statement.
\begin{lstlisting}
if condition {
    print "Condition is true"
}
\end{lstlisting}
If statement with an else block.
\begin{lstlisting}
if condition {
    print "Condition is true"
} else {
    print "Condition is false"
}
\end{lstlisting}
If statement with multiple nested conditions.
\begin{lstlisting}
if number == 0 {
    print "The number is 0"
} elif number == 1 {
    print "The number is 1"
} else {
    print "The number is not 0 nor 1"
}
\end{lstlisting}
If statement with the shorthand body.
\begin{lstlisting}
if number == 0 => print "The number is 0"
elif number == 1 => print "The number is 1"
else => print "The number is not 0 nor 1"
\end{lstlisting}

\subsection{While Statement}

A while statement is used to repeat a block of code while a certain expression (known as a condition) evaluates to \texttt{true}.
The condition is evaluated every time the loop is about to begin. If the while block is executed the program counter jumps back
to the condition to evaluate it again. When the condition is no longer true, the program counter skips the block and continues execution.
The while statement also has a shorthand to define its body when it only consists of a single statement.

\subsubsection{Caveats}

\begin{itemize}
    \item The condition must be a value of \texttt{bool} type. Explicit casting is needed.
\end{itemize}

\subsubsection{Examples}

Simple while statement.
\begin{lstlisting}
while condition {
    print "Condition is true"
}
\end{lstlisting}
Using the shorthand for single statements.
\begin{lstlisting}
while condition => print "Condition is true"
\end{lstlisting}
Real world while example
\begin{lstlisting}
a: int = 0
while a < 10 => {
    print a
    a = a + 1
}
\end{lstlisting}

\subsection{For Statement}

A for statement is very similar to a while statement but instead of working with a condition it works with an iterator.
An iterator is a data type that supports indexation and therefore, can be iterated. Nuua iterators are:

\begin{table}[H]
    \centering
    \begin{tabular}{ l l l }
        \textbf{Data type} & \textbf{Value Type} & \textbf{Index Type} \\
        \texttt{string} & \texttt{string} (a single character) & \texttt{int} \\
        \texttt{[T]}& \texttt{T} & \texttt{int} \\
        \texttt{\{T\}} & \texttt{T} & \texttt{string} \\
    \end{tabular}
    \caption{Nuua iterators}
    \label{fig:nuua_iterators}
\end{table}

Indexation is done with the \emph{Access} expression.
The for loop defines up to two variables to its block. One containing the current value of the indexed item and
another optional variable containing the current index being used.

\subsubsection{Caveats}

\begin{itemize}
    \item The value and the index are variables that are automatically declared with their respective types in the "for" block.
    \item The value and the index types are automatically inferred according to \autoref{fig:nuua_iterators}.
\end{itemize}

\subsubsection{Examples}

Simple for statement.
\begin{lstlisting}
for char in "string" {
    print char
}
\end{lstlisting}
For statement with the index.
\begin{lstlisting}
for letter, index in ["A", "B", "C"] {
    print index as string + ": " + letter
}
\end{lstlisting}
For statement with the shorthand.
\begin{lstlisting}
for num in 0..10 => print num
\end{lstlisting}

\subsection{Return Statement}

A return statement is used inside the function to determine its execution should end, and optionally return a value as the result.
Return statements are mandatory in functions that have a return type.

\subsubsection{Caveats}

\begin{itemize}
    \item If the function has a return type, at least one return at the top level of the function block is required. Otherwise, an error
        is thrown prior to execution.
    \item Return expression type must match the function's return type.
\end{itemize}

\subsubsection{Examples}

A simple return statement.
\begin{lstlisting}
fun a() {
    return
    print "Never executed"
}
\end{lstlisting}
A return statement returning a value.
\begin{lstlisting}
fun b(): int {
    return 10
}
\end{lstlisting}

\subsection{Print Statement}
\label{sec:print_statement}

The print statement is used to write a register to the \texttt{stdout} file.
This statement will be finally deleted alongside the keyword when a propper I/O is added into the language as mentioned in \autoref{sec:forthcomming}.

\subsubsection{Caveats}

\begin{itemize}
    \item Any data type can be printed with this statement. Even functions and objects.
\end{itemize}

\subsubsection{Examples}

A simple print statement.
\begin{lstlisting}
print "Hello, World"
\end{lstlisting}
A print of a function
\begin{lstlisting}
fun a(): int {
    print a
    return 10
}
\end{lstlisting}

\section{Expressions}

Expressions can always be reduced up to a value of a single data type. This section explains all the expressions that can be found
in Nuua.

Some of the expressions may have already been mentioned briefly in \autoref{sec:grammar_expressions}.

\subsection{Integer Expression}

The integer expressions can be written as an integer number directly in the source code.
Integer expressions return a value with the \texttt{int} data type.

\subsubsection{Caveats}

\begin{itemize}
    \item There are no prefix/postfix indicators to change the integer bit size or base (Like LL, 0x, etc.).
\end{itemize}

\subsubsection{Examples}

\begin{lstlisting}
0
25
81237
-6378
-1
\end{lstlisting}

\subsection{Float Expression}

The float expressions can be written as any floating point number, using a \texttt{"."} as the decimal delimiter, directly in the source code.
Float expressions return a value with the \texttt{float} data type.

\subsubsection{Caveats}

\begin{itemize}
    \item An integer followed by a \texttt{"."} without any other number on the right-hand side, it's considered an error. An explicit number
        must be written in the right-hand side to create a float expression, even to indicate \texttt{.0}.
\end{itemize}

\subsubsection{Examples}

\begin{lstlisting}
0.0
25.5
81237.11111
-6378.673
-1.9
\end{lstlisting}

\subsection{Boolean Expression}

The boolean expressions can be written as either \texttt{true} or \texttt{false} directly in the source code.
Boolean expressions return a value with the \texttt{bool} data type.

\subsubsection{Examples}

\begin{lstlisting}
true
false
\end{lstlisting}

\subsection{String Expression}

The string expressions can be written as any text enclosed between \texttt{'"'} directly in the source code.
String expressions return a value with the \texttt{string} data type.

\subsubsection{Caveats}

\begin{itemize}
    \item As for \today, the strings use a bare-bones C++ \texttt{std::string} to represent the string, that means that the string
        is a list of single-byte characters (characters in the ASCII character table). A plan to support wider characters is mentioned
        in \autoref{sec:forthcomming}.
\end{itemize}

\subsubsection{Examples}

\begin{lstlisting}
"A string is represented like this"
\end{lstlisting}

\subsection{List Expression}

The list expressions can be written as list of expressions separated by comma enclosed between \texttt{"["} and \texttt{"]"}
directly in the source code. A list inner type, say \texttt{T}, is determined by the type of the first expression of the list.
List expressions return a value with the \texttt{[T]} data type.

\subsubsection{Caveats}

\begin{itemize}
    \item List expression can't be empty due to an unknown type. Even when assigning them to a variable with a defined type. If there's the
        need for an empty list of a given type, declare a variable with the type and don't initialize it.
    \item Lists can only have a single type stored on it, therefore, if a list expression have more than one expression on it, the types
        must match. If a type does not match the first type of the list, an error is thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

A list expression that return a value of type \texttt{[string]}.
\begin{lstlisting}
["this", "is", "a", "valid", "list", "of", "strings"]
\end{lstlisting}
A list expression that return a value of type \texttt{[int]}.
\begin{lstlisting}
[1]
\end{lstlisting}

\subsection{Dictionary Expression}

The dictionary expressions can be written as a list of comma-separated pairs of \texttt{key: expression}
The key is an identifier representing the dictionary key willing to be used.
directly in the source code. A dictionary inner type, say \texttt{T}, is determined by the type of the first expression of the list.
Dictionary expressions return a value with the \texttt{\{T\}} data type.

\subsubsection{Caveats}

\begin{itemize}
    \item Dictionary expression can't be empty due to an unknown type. Even when assigning them to a variable with a defined type. If there's the
        need for an empty dictionary of a given type, declare a variable with the type and don't initialize it.
    \item Dictionaries can only have a single type stored on it, therefore, if a dictionary expression have more than one expression on it, the types
        must match. If a type does not match the first type of the dictionary, an error is thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

A dictionary expression that return a value of type \texttt{\{string\}}.
\begin{lstlisting}
{name: "Erik", occupation: "Student", color: "#ff0000"}
\end{lstlisting}
A dictionary expression that return a value of type \texttt{\{int\}}.
\begin{lstlisting}
{left: 10, right: 20, sum: 30}
\end{lstlisting}

\subsection{Object Expression}
\label{sec:object_expression}

The object expression is used to initialize an object of a given class. The object expression is used by writing the identifier of the class followed by
a \texttt{!} and list of comma-separated pairs of \texttt{key: expression} (where the key is an identifier) enclosed between \texttt{\{} and \texttt{\}}.
The keys in the argument list are the class properties willing to initialize and the expression is the value that the property is going to be assigned to.

\subsubsection{Caveats}

\begin{itemize}
    \item The keys found in the arguments must exist in the class properties. If one of the keys does not correspond to an existing class property an
        error is thrown prior to execution.
    \item The expressions of the keys in the argument list must match the class property type they want to initialize. If there's a type mismatch, an error
        is thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

An example class to provide the examples.
\begin{lstlisting}
class Person {
    name: string
    born_at: int
}
\end{lstlisting}
An object of class Person without arguments.
\begin{lstlisting}
Person!{}
\end{lstlisting}
An object of class Person with arguments.
\begin{lstlisting}
Person!{name: "Erik", born_at: 1997}
\end{lstlisting}

\subsection{Group Expression}

The group expression is used to give certain operations priority over the default operator precedence.
The group expression is an expression enclosed between \texttt{(} and \texttt{)}.

\subsubsection{Examples}

\begin{lstlisting}
(1 + 2) * 3 // 9
(1 + 4 - 3) * (2 * (2 + 2)) // 16
\end{lstlisting}

\subsection{Access Expression}

The access expression is used to access an inner value of another expressions. In short, the access expression can be used in any
Nuua iterator and the returned value is the inner value found on its index with the respective type as shown in \autoref{fig:nuua_iterators}.

\subsubsection{Caveats}

\begin{itemize}
    \item Only nuua iterators can be accessed.
\end{itemize}

\subsubsection{Examples}

A string access.
\begin{lstlisting}
"Hello"[1] // "e"
\end{lstlisting}
A list access.
\begin{lstlisting}
["Hello", "World"][1] // "World"
\end{lstlisting}
A dictionary access.
\begin{lstlisting}
{key1: "Hello", key2: "World"}["key1"] // "Hello"
\end{lstlisting}

\subsection{Slice Expression}

Slices act the same way as python slices and this explanation can be found in \autocite{python_right_way}. Basically, it's a way to
get a range of inner values in a Nuua iterator (Only those that can be index with an \texttt{int} type).
The supported parameters are:

\begin{table}[H]
    \centering
    \begin{tabular}{ l p{7.5cm} }
        \textbf{Parameter} & \textbf{Explanation} \\
        \texttt{start} & Starting index of the slice. Defaults to 0.\\
        \texttt{end} & The last index of the slice or the number of items to get. Defaults to the length of the iterator\\
        \texttt{step} & Optional. Extended slice syntax. Step value of the slice. Defaults to 1.\\
    \end{tabular}
    \caption{Slice parameters}
    \label{fig:slice_parameters}
\end{table}

\subsubsection{Caveats}

\begin{itemize}
    \item Only Nuua iterators whose inner value can be accessed using an \texttt{int} type can be sliced.
\end{itemize}

\subsubsection{Examples}

\begin{lstlisting}
"Hello"[1:3] // "el"
"Hello"[1:] // "ello"
"Hello"[:3] // "Hel"
"Hello"[::2] // "Hlo"
"Hello"[::-1] // "olleH"
\end{lstlisting}

\subsection{Call Expression}

The call expression is used to call a value. The value needs to be callable and Therefore the value must be a function.
When a call expression is used, its return value is the value returned from the function. The call accepts the arguments
that will be passed to the function as the function parameters.
The call expression is the caller and the target function is the callee.

\subsubsection{Caveats}

\begin{itemize}
    \item If the callee has no return value, then the caller is banned from being treated as an expression, only being
        able to be used where its value is not used.
\end{itemize}

\subsubsection{Examples}

An example function acting as a callee.
\begin{lstlisting}
fun test(a: int): int -> a + 1
\end{lstlisting}
An example call.
\begin{lstlisting}
test(10) // 11
\end{lstlisting}

\subsection{Property Expression}

The property expression is used to access a specific property in an object, meaning that the target expression can only be
an object. The property name is the identifier used after the dot.

\subsubsection{Caveats}

\begin{itemize}
    \item If the object class has no property named as the identifier, an error is thrown prior to execution.
    \item If the object is not initialized, a runtime segmentation fault error is thrown.
\end{itemize}

\subsubsection{Examples}

An example class to work with.
\begin{lstlisting}
class Person {
    name: string
}
\end{lstlisting}
An example property expression.
\begin{lstlisting}
Person!{name: "Erik"}.name // "Erik"
\end{lstlisting}

\subsection{Unary Expression}

The unary expression is an expression that has an operation attached to it. Prefix notation is used to specify the operation
to the expression. The list of available unary operations is found in \autoref{fig:unary_ops}.

\begin{table}[H]
    \centering
    \begin{tabular}{ l p{7.5cm} }
        \textbf{Operation symbol} & \textbf{Operation} \\
        \texttt{-} & Unary negation of the expression on the right. The right expression must be an \texttt{int}, a \texttt{float} or a \texttt{bool}\\
        \texttt{+} & Positive version of the \texttt{-}. Can be used to cast a \texttt{bool} to an \texttt{int}.
            The right expression must be an \texttt{int}, a \texttt{float} or a \texttt{bool}\\
        \texttt{!} & Logical negation, the right expression must be a \texttt{bool}.\\
    \end{tabular}
    \caption{Unary operations}
    \label{fig:unary_ops}
\end{table}

\subsubsection{Caveats}

\begin{itemize}
    \item A positive sign can be used to cast a \texttt{bool} to an int, although conventional casting can be used.
\end{itemize}

\subsubsection{Examples}

Example unary operations
\begin{lstlisting}
-10 // -10
-(10 + 2) // -12
!false // true
+true // 1
\end{lstlisting}

\subsection{Cast Expression}

The cast expression is used to perform type conversion on values. The casts are checked prior to execution, and the supported list
of casts is show in \autoref{fig:nuua_casts}.

\begin{table}[H]
    \centering
    \begin{tabular}{ l l p{9.5cm} }
        \textbf{Input type} & \textbf{Cast type} & \textbf{Notes} \\
        \texttt{int} & \texttt{float} & Possible data loss.\\
        \texttt{int} & \texttt{bool} & \texttt{false} when the value is \texttt{0}, otherwise \texttt{true}.\\
        \texttt{int} & \texttt{string} & Conversion to a string representation.\\
        \texttt{float} & \texttt{int} & Decimals are truncated. Possible data loss.\\
        \texttt{float} & \texttt{bool} & \texttt{false} when the value is \texttt{0.0}, otherwise \texttt{true}.\\
        \texttt{float} & \texttt{string} & Conversion to a string representation.\\
        \texttt{bool} & \texttt{int} & \texttt{0} when the value is \texttt{false}, otherwise \texttt{1}.\\
        \texttt{bool} & \texttt{float} & \texttt{0.0} when the value is \texttt{false}, otherwise \texttt{1.0}.\\
        \texttt{bool} & \texttt{string} & Conversion to a string representation.\\
        \texttt{string} & \texttt{bool} & \texttt{false} when the string length is \texttt{0}, otherwise \texttt{true}\\
        \texttt{string} & \texttt{int} & Returns the string length.\\
        \texttt{[T]} & \texttt{string} & Conversion to a string representation.\\
        \texttt{[T]} & \texttt{bool} & \texttt{false} when the list length is \texttt{0}, otherwise \texttt{true}\\
        \texttt{[T]} & \texttt{int} & Returns the list length.\\
        \texttt{\{T\}} & \texttt{string} & Conversion to a string representation.\\
        \texttt{\{T\}} & \texttt{bool} & \texttt{false} when the dictionary length is \texttt{0}, otherwise \texttt{true}\\
        \texttt{\{T\}} & \texttt{int} & Returns the dictionary length.\\
    \end{tabular}
    \caption{Nuua casts}
    \label{fig:nuua_casts}
\end{table}

\subsubsection{Examples}

Example casting operations.
\begin{lstlisting}
10 as float // 10.0
25.8 as int // 25
false as string // "false"
[1, 2, 3] as string // "[1, 2, 3]"
[20, 30] as int // 2
\end{lstlisting}

\subsection{Binary Expression}

The binary expression is used to perform an operation that require two values to be done with the exception of the logical expression
that is treated differently. The binary operations that can be performed are shown in
\autoref{fig:nuua_additive_bin_ops}, \autoref{fig:nuua_multiplicative_bin_ops},
\autoref{fig:nuua_relational_equality_bin_ops} and \autoref{fig:nuua_relational_ordering_bin_ops}.

\begin{table}[H]
	\centering
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{+} & \texttt{int} & \texttt{int} & \texttt{int} addition.\\
            \texttt{float} & \texttt{+} & \texttt{float} & \texttt{float} & \texttt{float} addition.\\
            \texttt{string} & \texttt{+} & \texttt{string} & \texttt{string} & \texttt{string} concatenation.\\
            \texttt{bool} & \texttt{+} & \texttt{bool} & \texttt{int} & \texttt{bool} addition.\\
            \texttt{[T]} & \texttt{+} & \texttt{[T]} & \texttt{[T]} & \texttt{[T]} concatenation.\\
            \texttt{\{T\}} & \texttt{+} & \texttt{\{T\}} & \texttt{\{T\}} & \texttt{\{T\}} concatenation.\\
		\end{tabular}
		\caption{Addition}
	\end{subtable}
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{-} & \texttt{int} & \texttt{int} & \texttt{int} subtraction.\\
            \texttt{float} & \texttt{-} & \texttt{float} & \texttt{float} & \texttt{float} subtraction.\\
            \texttt{bool} & \texttt{-} & \texttt{bool} & \texttt{int} & \texttt{bool} subtraction.\\
		\end{tabular}
		\caption{Substraction}
	\end{subtable}
	\caption{Nuua additive binary operations}
    \label{fig:nuua_additive_bin_ops}
\end{table}

\begin{table}[H]
	\centering
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{*} & \texttt{int} & \texttt{int} & \texttt{int} multiplication.\\
            \texttt{float} & \texttt{*} & \texttt{float} & \texttt{float} & \texttt{float} multiplication.\\
            \texttt{bool} & \texttt{*} & \texttt{bool} & \texttt{int} & \texttt{bool} multiplication.\\
            \texttt{int} & \texttt{*} & \texttt{string} & \texttt{string} & \texttt{string} repetition.\\
            \texttt{string} & \texttt{*} & \texttt{int} & \texttt{string} & \texttt{string} repetition.\\
            \texttt{int} & \texttt{*} & \texttt{[T]} & \texttt{[T]} & \texttt{[T]} repetition.\\
            \texttt{[T]} & \texttt{*} & \texttt{int} & \texttt{[T]} & \texttt{[T]} repetition.\\
		\end{tabular}
		\caption{Multiplication}
	\end{subtable}
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{/} & \texttt{int} & \texttt{float} & \texttt{int} division.\\
            \texttt{float} & \texttt{/} & \texttt{float} & \texttt{float} & \texttt{float} division.\\
            \texttt{string} & \texttt{/} & \texttt{int} & \texttt{[string]} & \texttt{string} division.\\
            \texttt{[T]} & \texttt{/} & \texttt{int} & \texttt{[[T]]} & \texttt{[T]} division.\\
		\end{tabular}
		\caption{Division}
	\end{subtable}
	\caption{Nuua multiplicative binary operations}
    \label{fig:nuua_multiplicative_bin_ops}
\end{table}

\begin{table}[H]
	\centering
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{==} & \texttt{int} & \texttt{bool} & \texttt{int} equality.\\
            \texttt{float} & \texttt{==} & \texttt{float} & \texttt{bool} & \texttt{float} equality.\\
            \texttt{string} & \texttt{==} & \texttt{string} & \texttt{bool} & \texttt{string} equality.\\
            \texttt{bool} & \texttt{==} & \texttt{bool} & \texttt{bool} & \texttt{bool} equality.\\
            \texttt{[T]} & \texttt{==} & \texttt{[T]} & \texttt{bool} & \texttt{[T]} equality.\\
            \texttt{\{T\}} & \texttt{==} & \texttt{\{T\}} & \texttt{bool} & \texttt{\{T\}} equality.\\
		\end{tabular}
		\caption{Equality}
	\end{subtable}
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{!=} & \texttt{int} & \texttt{bool} & \texttt{int} inequality.\\
            \texttt{float} & \texttt{!=} & \texttt{float} & \texttt{bool} & \texttt{float} inequality.\\
            \texttt{string} & \texttt{!=} & \texttt{string} & \texttt{bool} & \texttt{string} inequality.\\
            \texttt{bool} & \texttt{!=} & \texttt{bool} & \texttt{bool} & \texttt{bool} inequality.\\
            \texttt{[T]} & \texttt{!=} & \texttt{[T]} & \texttt{bool} & \texttt{[T]} inequality.\\
            \texttt{\{T\}} & \texttt{!=} & \texttt{\{T\}} & \texttt{bool} & \texttt{\{T\}} inequality.\\
		\end{tabular}
		\caption{Inequality}
	\end{subtable}
	\caption{Nuua relational equality binary operations}
    \label{fig:nuua_relational_equality_bin_ops}
\end{table}

\begin{table}[H]
	\centering
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{>} & \texttt{int} & \texttt{bool} & \texttt{int} higher than.\\
            \texttt{float} & \texttt{>} & \texttt{float} & \texttt{bool} & \texttt{float} higher than.\\
            \texttt{string} & \texttt{>} & \texttt{string} & \texttt{bool} & \texttt{string} higher than.\\
            \texttt{bool} & \texttt{>} & \texttt{bool} & \texttt{bool} & \texttt{bool} higher than.\\
		\end{tabular}
		\caption{Higher than}
	\end{subtable}
	\begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{>=} & \texttt{int} & \texttt{bool} & \texttt{int} higher than or equal.\\
            \texttt{float} & \texttt{>=} & \texttt{float} & \texttt{bool} & \texttt{float} higher than or equal.\\
            \texttt{string} & \texttt{>=} & \texttt{string} & \texttt{bool} & \texttt{string} higher than or equal.\\
            \texttt{bool} & \texttt{>=} & \texttt{bool} & \texttt{bool} & \texttt{bool} higher than or equal.\\
		\end{tabular}
		\caption{Higher than or equal}
	\end{subtable}
    \begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{<} & \texttt{int} & \texttt{bool} & \texttt{int} lower than.\\
            \texttt{float} & \texttt{<} & \texttt{float} & \texttt{bool} & \texttt{float} lower than.\\
            \texttt{string} & \texttt{<} & \texttt{string} & \texttt{bool} & \texttt{string} lower than.\\
            \texttt{bool} & \texttt{<} & \texttt{bool} & \texttt{bool} & \texttt{bool} lower than.\\
		\end{tabular}
		\caption{Lower than}
	\end{subtable}
    \begin{subtable}{\textwidth}
		\centering
        \begin{tabular}{ l l l l p{9.5cm} }
            \textbf{Left type} & \textbf{Operation} & \textbf{Right type} & \textbf{Result type} & \textbf{Notes} \\
            \texttt{int} & \texttt{<=} & \texttt{int} & \texttt{bool} & \texttt{int} lower than or equal.\\
            \texttt{float} & \texttt{<=} & \texttt{float} & \texttt{bool} & \texttt{float} lower than or equal.\\
            \texttt{string} & \texttt{<=} & \texttt{string} & \texttt{bool} & \texttt{string} lower than or equal.\\
            \texttt{bool} & \texttt{<=} & \texttt{bool} & \texttt{bool} & \texttt{bool} lower than or equal.\\
		\end{tabular}
		\caption{Lower than or equal}
	\end{subtable}
	\caption{Nuua relational ordering binary operations}
    \label{fig:nuua_relational_ordering_bin_ops}
\end{table}

\subsubsection{Examples}

Example binary operations.
\begin{lstlisting}
10 + 20 // 30
20 < 50 // true
"sample" == "sample"
"abc" * 2 // "abcabc"
"erik" / 4 // ["e", "r", "i", "k"]
\end{lstlisting}

\subsection{Logical Expression}

The logical expression is used to perform a logical operation on two values. The logical operations supported are
the \texttt{and} and the \texttt{or} operations that perform a logical conjunction and a logical disjunction respectively.

\subsubsection{Caveats}

\begin{itemize}
    \item The values on both sides of the logical expression are required to be of type \texttt{bool}. Explicit casting is needed.
    \item If one or both values are not of type bool, an error is thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

Example logical \texttt{and}.
\begin{lstlisting}
true and false // false
true and true // true
\end{lstlisting}
Example logical \texttt{or}.
\begin{lstlisting}
true or false // true
true or true // true
\end{lstlisting}

\subsection{Range Expression}

The range expression is used to create a list ranging from a \texttt{start} index to an \texttt{end} index.
This expression allows for quick lists to be created and ready to worth with a single line. The range can be
inclusive or exclusive depending on the number of dots found in the expression.

\subsubsection{Caveats}

\begin{itemize}
    \item The \texttt{start} and the \texttt{end} index must be of type \texttt{int}. If not, an error is thrown prior to execution.
    \item Inclusive ranges use three dots, while an exclusive range uses two dots.
\end{itemize}

\subsubsection{Examples}

Example ranges.
\begin{lstlisting}
0..3 // [0, 1, 2]
-2...2 // [-2, -1, 0, -1, -2]
\end{lstlisting}

\subsection{Assignment Expression}

The assignment expression is used to assign a value to a target. Target may be a variable, an access expression or a property expression.
The left side (target) is then assigned the expression on the right side (value). The assignment expression returns the assignment value.

\subsubsection{Caveats}

\begin{itemize}
    \item The types of the target and the value must match to perform an assignment. If not, an error is thrown prior to execution.
\end{itemize}

\subsubsection{Examples}

Example variable assignment.
\begin{lstlisting}
test: int
test = 20 // 20
\end{lstlisting}
Example access assignment.
\begin{lstlisting}
l := [1, 2, 3]
l[1] = 4 // 4
// The value of l will now be [1, 4, 3]
d := {"a": 10, "b": 20}
d["a"] = 5 // 5
// The value of d will now be {"a": 5, "b": 20}
\end{lstlisting}
Example property assignment.
\begin{lstlisting}
class Person {
    name: string
}
p := Person!{name: "Erik"}
p.name = "User" // "User"
// The value of p will now be Person!{name: "User"}
\end{lstlisting}

\section{Comments}

Comments in Nuua can be written by using a double backslash (\texttt{\textbackslash\textbackslash}) followed by the comment text.
The comment text lasts till a \texttt{\textbackslash n} character is found. Therefore, multiline comments can be done
by manually writing the double backslash on each different line.

Comment blocks are not part of the language grammar and therefore they are totally discarded from the AST. When
the lexer finds the double backslash, it proceeds to discard the whole line.

\begin{lstlisting}
// Some comment here
fun test() {
    print "Hello"
    // Some other comment here
    print "Hello again"
}
\end{lstlisting}
