The job of the parser is to transform the list of tokens returned by the Lexer into an abstract syntax tree.\\

\begin{figure}[H]
    \centering
    \begin{tikzpicture}
        [node distance=1cm]

        % Nodes of the layered system
        \node[block] (input) {List of tokens};
        \node[block,right=of input] (parser) {Parser};
        \node[block,right=of lexer] (output) {Abstract Syntax Tree};

        % Lines
        \draw[line] (input) -- (parser);
        \draw[line] (parser) -- (output);

    \end{tikzpicture}

    % Caption and Label
    \caption{Parser overview}
    \label{fig:parser_overview}
\end{figure}

There are a lot of different algorithms and strategies for parsing different set of grammars.
There are also a lot of parser generators out there that can help building a parser. However, this thesis implements
a hand written top down recursive descend predictive parser for the following main reasons:

\begin{enumerate}
    \item To have as much control as needed over the parser. Specially for error reporting.
    \item To enforce a zero-dependency policy.
    \item Easy to build and fast enough for the job.
    \item To learn how to build a recursive descend parser and learn how it works.
\end{enumerate}

Recursive descend parsers are probably the simplest way to build a parser as mentioned in \autocite[Section~6]{crafting_interpreters}.
In fact, even if it's a simple parser it's used in very famous and large projects like \texttt{GCC} or \texttt{V8}.

As can be seen on \autocite{top_down_parsing} the top down parers can be classified into the ones using backtracking and the ones using a predictive technique.

\begin{itemize}
    \item \emph{Backtracking parsers}: Backtracking parsers try to guess the correct production rule based on the current token. This guess can however, lead to a
        dead-end and therefore a backtrack is needed to go back and make anothe decision. This is hoever, very inefficient for programming languages due the ammount
        of nonterminals found in them.
    \item \emph{Predictive parsers}: Predictive parsers choose the production rule acording to the current token and the next token found. The next tooken is called
        a lookahead token. Predictive parsers have a major issue with left-recursion and therefore, the language grammar needs to be adapted to it.
        The Nuua grammar as seen on \autoref{sec:nuua_grammar} is already adapted for left-recursion based on the solution mentioned on
        \autocite[Section~6]{crafting_interpreters}.
\end{itemize}

A recursive descend parser is a possible technique for implementing a top-down predictive parser that consists in the creation of a funciton for each
nonterminal found in the grammar and then calling the functions depending on the current token and the lookahead.

\section{Abstract Syntax Tree}

The abstract syntax tree (AST) is the data structure used to represent the program in memory. This tree contains the
representation of the whole program starting from an initial node \texttt{program} as seen in \autoref{sec:program_tld}.
\autoref{fig:ast_example} shows an example AST.

\begin{figure}[H]
	\centering
	\begin{subtable}{0.45\textwidth}
		\centering
        \texttt{1 - 2 * -3}
		\caption{Program}
	\end{subtable}
	\begin{subtable}{0.45\textwidth}
		\centering
        \texttt{TOKEN\_INTEGER TOKEN\_MINUS TOKEN\_INTEGER TOKEN\_STAR TOKEN\_MINUS TOKEN\_INTEGER}
		\caption{List of tokens}
	\end{subtable}
    \begin{subfigure}{0.45\textwidth}
		\centering
        \begin{tikzpicture}[node distance=1.75cm]
            % Nodes
            \node[state] (1) {\texttt{-}};
            \node[state, below left of=1] (2) {\texttt{1}};
            \node[state, below right of=1] (3) {\texttt{*}};
            \node[state, below left of=3] (4) {\texttt{2}};
            \node[state, below right of=3] (5) {\texttt{-}};
            \node[state, below of=5] (6) {\texttt{3}};
            % Lines
            \draw (1) -- (2);
            \draw (1) -- (3);
            \draw (3) -- (4);
            \draw (3) -- (5);
            \draw (5) -- (6);
        \end{tikzpicture}
		\caption{Abstract syntax tree}
	\end{subfigure}
    \begin{subfigure}{0.45\textwidth}
		\centering
        \begin{tikzpicture}[node distance=1.75cm]
            % Nodes
            \node[state] (0) {\texttt{P(1)}};
            \node[state, below of=0] (1) {\texttt{B(+)}};
            \node[state, below left of=1] (2) {\texttt{1}};
            \node[state, below right of=1] (3) {\texttt{B(*)}};
            \node[state, below left of=3] (4) {\texttt{2}};
            \node[state, below right of=3] (5) {\texttt{U(-)}};
            \node[state, below of=5] (6) {\texttt{3}};
            % Legend
            \node[text width=4.5cm, align=left, right = 0.5cm of 0.east] (l) {

                { \footnotesize \noindent
                    \texttt{P(n):\\\quad Program (n statements)}\\\texttt{B(operation):\\\quad Binary operation}\\\texttt{U(operation):\\\quad Unary operation}
                }
            };
            % Lines
            \draw (0) -- (1);
            \draw (1) -- (2);
            \draw (1) -- (3);
            \draw (3) -- (4);
            \draw (3) -- (5);
            \draw (5) -- (6);
        \end{tikzpicture}
		\caption{Nuua AST}
	\end{subfigure}
	\caption{Example abstract syntax tree}
    \label{fig:ast_example}
\end{figure}

\section{Block Scope}

\section{Data Types}

\section{Tree Nodes}

\section{Parser Class}
